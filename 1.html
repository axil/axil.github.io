<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8"> 
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="Lev Maximov" />
        <meta name="copyright" content="Lev Maximov" />
        <link rel="canonical" href="https://medium.com/@levmaximov/8f62cb57ea83?sk=a417246f0cf9e24aca734525711299d3">
        <meta name="monetization" content="$ilp.uphold.com/y4ZnwiyRnb8i" />

<meta name="keywords" content=", numpy-data-types, " />
        <title>A Comprehensive Guide to NumPy Data Types - axil's blog
</title>
        <link href="./theme/css/slim-081711.css" rel="stylesheet" type="text/css">
        <link href="./theme/css/bootstrap-combined.min.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="./theme/css/style.css" media="screen">
        <link rel="stylesheet" type="text/css" href="./theme/css/solarizedlight.css" media="screen">
        <link rel="stylesheet" type="text/css" href="./css/custom.css" media="screen">
        <link rel="shortcut icon" href="./theme/images/favicon.ico" type="image/x-icon" />
        <link rel="apple-touch-icon" href="./theme/images/apple-touch-icon.png" />
        <link rel="apple-touch-icon" sizes="57x57" href="./theme/images/apple-touch-icon-57x57.png" />
        <link rel="apple-touch-icon" sizes="72x72" href="./theme/images/apple-touch-icon-72x72.png" />
        <link rel="apple-touch-icon" sizes="114x114" href="./theme/images/apple-touch-icon-114x114.png" />
        <link rel="apple-touch-icon" sizes="144x144" href="./theme/images/apple-touch-icon-144x144.png" />
        <link rel="icon" href="./theme/images/apple-touch-icon-144x144.png" />
	
    </head>
    <body>
        <div id="content-sans-footer">
        <div class="navbar navbar-static-top">
            <div class="navbar-inner">
                <div class="container">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <a class="brand" href="./"><span class=site-name>axil's blog</span></a>
                    <div class="nav-collapse collapse">
                        <ul class="nav pull-right top-menu">
                            <li ><a href=".">Home</a></li>
                            <li ><a href="./categories.html">Categories</a></li>
                            <li ><a href="./tags.html">Tags</a></li>
                            <li ><a href="./archives.html">Archives</a></li>
                            <li><form class="navbar-search" action="./search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="container-fluid">
            <div class="row-fluid">
                <div class="span1"></div>
                <div class="span10">
<article>
<div class="row-fluid">
    <header class="page_header span10 offset2">
    <h1><a href="./a-comprehensive-guide-to-numpy-data-types.html"> A Comprehensive Guide to NumPy Data Types  </a></h1>
    </header>
</div>

<div class="row-fluid">
        <div class="span8 offset2 article-content">

            <img alt="NumPy Types Diagram" src="img/numpy-data-types/numpy_types_diagram.png" />
<p>NumPy, one of the most popular Python libraries for both data science and scientific computing, is pretty omnivorous when it comes to data types: it can handle just everything.</p>
<p>It has its own set of ‘native’ types which it is capable of processing at full speed but it can also work with pretty much anything known to Python.</p>
<p>The article consists of 7 parts:</p>
<p><a class="reference internal" href="#integers">1. Integers</a> <br/>
<a class="reference internal" href="#floats">2. Floats</a> (including Fractions and Decimals) <br/>
<a class="reference internal" href="#bools">3. Bools</a> <br/>
<a class="reference internal" href="#strings">4. Strings</a>  <br/>
<a class="reference internal" href="#datetimes">5. Datetimes</a> <br/>
<a class="reference internal" href="#combinations-thereof">6. Combinations thereof</a> <br/>
<a class="reference internal" href="#type-checks">7. Type Checks</a></p>
<div class="section" id="integers">
<h2>1. Integers</h2>
<p>The integer types table in NumPy is absolutely trivial for anyone with minimal experience in C/C++:</p>
<img alt="NumPy Integer Types" src="img/numpy-data-types/integers.png" />
<p>Just like in C/C++, <cite>u</cite> stands for 'unsigned' and the number is the amount of bits used to store the variable in memory (eg int64 is a 8-bytes-wide signed integer).</p>
<p>When you feed a Python int into NumPy, it gets converted into a native NumPy type called np.int32 (or np.int64 depending on the OS, Python version and the magnitude of the initializers):</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">dtype</span>
<span class="n">dtype</span><span class="p">(</span><span class="s1">'int32'</span><span class="p">)</span>                   <span class="c1"># int32 on Windows, int64 on Linux and MacOS</span>
</pre>
<p>If you’re unhappy with the 'flavor' of the integer type that NumPy has chosen for you, you can specify one explicitly: np.array([1,2,3], np.uint8) or np.array([1,2,3], 'uint8').</p>
<p>NumPy works best when the width of the array elements is fixed. It is faster and takes less memory, but unlike an ordinary Python int (that works in arbitrary precision arithmetic) the value will wrap when it crosses the maximum (or minimum) value for the corresponding data type:</p>
<img alt="Int Wrapping" src="img/numpy-data-types/int_wrapping.png" />
<p>* <em>Strictly speaking, the C standard defines this wraparound only for the unsigned integers; the overflow behavior for the signed integers is undefined and can’t be relied upon (in both C and NumPy). Signed integers are silently wrapped around now, but there’s no guarantee they always will.</em></p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">255</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>   <span class="c1"># 2**8-1 is INT_MAX for uint8</span>
<span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint8</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>             <span class="c1"># 2**31-1 is INT_MAX for int32</span>
<span class="n">array</span><span class="p">([</span><span class="mi">2147483647</span><span class="p">])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>         <span class="c1"># or np.array([2**31-1], np.int32)+1 on linux</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">2147483648</span><span class="p">])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="o">**</span><span class="mi">63</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>         <span class="c1"># always np.int64 since v &gt; 2**32-1</span>
<span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">9223372036854775808</span><span class="p">])</span>
</pre>
<p>— not even a warning here!</p>
<p>With scalars it is a different story: first NumPy tries it best to promote the value to a wider type, then, if there is none, fires the overflow warning (to avoid flooding the output with warnings—only once):</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">255</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>   <span class="c1"># ok, promoted to int32(win)/int64(linux)</span>
<span class="mi">256</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>         <span class="c1"># warning!</span>
<span class="ne">RuntimeWarning</span><span class="p">:</span> <span class="n">overflow</span> <span class="n">encountered</span> <span class="ow">in</span> <span class="n">long_scalars</span>
<span class="o">-</span><span class="mi">2147483648</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="o">**</span><span class="mi">63</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>         <span class="c1"># ok, warned already</span>
<span class="o">-</span><span class="mi">9223372036854775808</span>
</pre>
<p>The reasoning behind such a discrimination is like this:</p>
<blockquote>
Unlike true floating point errors (where the hardware FPU sets a flag whenever it does an atomic operation that overflows), we need to implement the integer overflow detection ourselves. We do it on the scalars, but not arrays because it would be too slow to implement for every atomic operation on arrays. <em>Robert Kern, one of the NumPy core developers</em></blockquote>
<p>You can turn it into an error:</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">over</span><span class="o">=</span><span class="s1">'raise'</span><span class="p">):</span>
<span class="o">&gt;&gt;&gt;</span>    <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="ne">FloatingPointError</span><span class="p">:</span> <span class="n">overflow</span> <span class="n">encountered</span> <span class="ow">in</span> <span class="n">long_scalars</span>
</pre>
<p>(although the name FloatingPointError for an <em>integer</em> overflow looks a bit misleading.)</p>
<p>... or suppress it entirely:</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">over</span><span class="o">=</span><span class="s1">'ignore'</span><span class="p">):</span>
<span class="o">&gt;&gt;&gt;</span>    <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="o">-</span><span class="mi">2147483648</span>
</pre>
<p>But you can’t expect it to be detected when dealing with arrays (even with the 0-dimensional ones!).</p>
<p>NumPy also has a bunch of C-style aliases (eg. np.byte np.int8, np.short=np.int16, np.intc=int whichever width it has in C etc), but they are getting gradually phased out (eg <a class="reference external" href="https://numpy.org/devdocs/release/1.20.0-notes.html#using-the-aliases-of-builtin-types-like-np-int-is-deprecated">deprecation of np.long in NumPy v1.20.0</a>) as 'explicit is better than implicit' (but see a present-day usage of np.longdouble below).</p>
<p>And yet some more exotic aliases:</p>
<ul class="simple">
<li><cite>np.int_</cite> is np.int32 on 64bit windows but int64 on 64bit linux, used to designate the 'default' int. Specifying <cite>np.int_</cite> (or just int) as a dtype means &quot;do what you would do if I didn't specify any dtype at all&quot;: np.array([1,2]), np.array([1,2], <cite>np.int_</cite>) and np.array([1,2], int) are all the same thing.</li>
<li><cite>np.intp</cite> is np.int32 on 32bit python but np.int64 on 64bit python, ≈ssize_t in C, used in Cython as a type for pointers.</li>
</ul>
<p>Occasionally it happens that some of the values in the array display anomalous behavior or missing and you want to process the array without deleting them (eg there's some valid data in other columns).</p>
<p>You can't put None there because it doesn't fit in the consecutive np.int64 values and also because 1+None is an unsupported operation.</p>
<p>Pandas has a separate data type for that, but NumPy's way of dealing with the missed values is through the so-called masked array: you mark the invalid values with a boolean mask and then all the operations are carried out as if the values are not there.</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>          <span class="c1"># the value 0 means 'missing' here</span>
<span class="mf">3.3333333333333335</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy.ma</span> <span class="k">as</span> <span class="nn">ma</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="mf">5.0</span>
</pre>
<p>Finally, if for some reason you need arbitrary-precision integers (Python ints) in ndarrays, NumPy is capable of doing that, too:</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="o">**</span><span class="mi">1000</span><span class="p">))</span>                   <span class="c1"># '[1000...0]'</span>
<span class="mi">1003</span>
</pre>
<p>— but without the usual speedup as it will have to store references instead of the numbers themselves, keep boxing/unboxing Python objects when processing, etc.</p>
</div>
<div class="section" id="floats">
<h2>2. Floats</h2>
<p>As Python did not diverge from IEEE 754-standardized C double type, the floating type transition from Python to NumPy is pretty much hassle-free:</p>
<img alt="NumPy Floating Types" src="img/numpy-data-types/floats.png" />
<p>* As reported by np.finfo(np.float&lt;nn&gt;).precision.Deending on what you mean it may be:  15* (<a class="reference external" href="https://en.cppreference.com/w/cpp/types/numeric_limits/digits10">15</a>) <em>or</em> ( <a class="reference external" href="https://en.cppreference.com/w/cpp/types/numeric_limits/max_digits10">17 FLT_DECIMAL_DIG</a>) for np.float64, 6 or 9 for np.float32, etc.</p>
<p>** As of today, np.float128 is Unix-only (not available on Windows).</p>
<p>Like integers, floats are also subject to overflow errors.</p>
<p>Suppose you're calculating a sigmoid activation function of the array and one of its element happens to be</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1234.5</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">))</span>
<span class="ne">RuntimeWarning</span><span class="p">:</span> <span class="n">overflow</span> <span class="n">encountered</span> <span class="ow">in</span> <span class="n">exp</span>
<span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1234.5</span><span class="p">]))</span>
<span class="ne">RuntimeWarning</span><span class="p">:</span> <span class="n">overflow</span> <span class="n">encountered</span> <span class="ow">in</span> <span class="n">exp</span>
<span class="n">array</span><span class="p">([</span><span class="n">inf</span><span class="p">])</span>
</pre>
<p>What this warning is trying to tell you is that NumPy is aware that mathematically speaking 1/(1+exp(-x)) should never be 0., but in this particular case due an overflow it is.
Such warnings can be 'upgraded' to exceptions or silenced via the errstate or filterwarnings as described in the 'integers' section above - and maybe for this particular case that would be enough - but if you really want to get the exact value you can select a wider dtype:</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">1234.5</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float128</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">))</span>
<span class="n">array</span><span class="p">([</span><span class="mf">7.30234068e-537</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float128</span><span class="p">)</span>
</pre>
<p>Just like in pure Python, NumPy floats exactly represent integers—but only below a certain level (limited by the number of the significant digits):</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="o">**</span><span class="mi">24</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">);</span> <span class="n">a</span>    <span class="c1"># 2^(mantissa_bits+1)</span>
<span class="n">array</span><span class="p">([</span><span class="mf">16777216.</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float32</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">+</span><span class="mi">1</span>
<span class="n">array</span><span class="p">([</span><span class="mf">16777216.</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float32</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="mf">9279945539648888.0</span><span class="o">+</span><span class="mi">1</span>    <span class="c1"># for float64 it is 2.**53</span>
<span class="mf">9279945539648888.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="s1">'9279945539648888'</span><span class="p">)</span> <span class="c1"># Don't trust the 16th decimal digit!</span>
<span class="mi">16</span>
</pre>
<p>Also exactly representable are fractions like 0.5, 0.125, 0.875 where the denominator is a power of 2 (0.5=1/2, 0.125=1/8, 0.875 =7/8, etc).</p>
<p>Any other denominator will result in a rounding error so that 0.1+0.2!=0.3. The standard approach of dealing with this problem is to compare them with a relative tolerance (to compare two non-zero arguments) and absolute tolerance (if one of the arguments is zero). For scalars it is handled by <cite>math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0)</cite>, for NumPy arrays there’s a vectorized version <cite>np.isclose(a, b, rtol=1e-05, atol=1e-08)</cite>. Note that the tolerance arguments have different names and defaults.</p>
<p>For the financial data decimal.Decimal type is handy as it involves no tolerances at all:</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span> <span class="k">as</span> <span class="n">D</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">D</span><span class="p">(</span><span class="s1">'0.1'</span><span class="p">),</span> <span class="n">D</span><span class="p">(</span><span class="s1">'0.2'</span><span class="p">)]);</span> <span class="n">a</span>
<span class="n">array</span><span class="p">([</span><span class="n">Decimal</span><span class="p">(</span><span class="s1">'0.1'</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="s1">'0.2'</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>                     <span class="c1"># == Decimal('0.3'), exactly</span>
<span class="n">Decimal</span><span class="p">(</span><span class="s1">'0.3'</span><span class="p">)</span>
</pre>
<p>But Decimal type is not a silver bullet: it also has rounding errors. The only problem it solves is the exact representation of decimal fractions that humans are so used to. Plus it doesn’t support anything more complicated than arithmetic operations and a square root and runs slower than floats.</p>
<p>For pure mathematical calculations fractions.Fraction can be used:</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">fractions</span> <span class="kn">import</span> <span class="n">Fraction</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="n">Fraction</span><span class="p">();</span> <span class="n">a</span>
<span class="n">array</span><span class="p">([</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">/=</span><span class="mi">10</span><span class="p">;</span> <span class="n">a</span>
<span class="n">array</span><span class="p">([</span><span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="n">Fraction</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</pre>
<p>It can represent any rational number, but pi and exp are out of luck )</p>
<p>Both Decimal and Fraction are not native types for NumPy but it is capable of working with them with all the niceties like multi-dimensions and fancy indexing, albeit at the cost of slower processing speed than that of native ints or floats.</p>
<p>Complex numbers are processed no differently than floats with extra convenience functions with intuitive names like np.real(z), np.imag(z), np.abs(z), np.angle(z) that work on both scalars and arrays as a whole. The only gotcha is that unlike pure Python complex, <cite>np.complex_</cite> does not work with integers:</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="n">j</span><span class="p">])</span>                  <span class="c1"># .dtype == np.complex128</span>
<span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="o">+</span><span class="mf">2.</span><span class="n">j</span><span class="p">])</span>
</pre>
<p>Just like with the integers, in float (and complex) arrays it is also sometimes useful to treat certain values as 'missing'. Floats are better suited for storing anomalous data: they have a math.nan (or np.nan or float('nan')) value which can be stored inline with the 'valid' numeric values.</p>
<p>But nan is contagious in the sense that all the arithmetic with nan results in nan.Most common statistical functions have a nan-resistant version (np.nansum, np.nanstd, etc), but other operations on that column or array would require prefiltering. Masked arrays automate this step: the mask can only be built once, then it is 'glued' to the original array so that all subsequent operations only see the unmasked values and operate on them.</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">4.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mf">6.</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="n">nan</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">nanmean</span><span class="p">()</span>
<span class="mf">5.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="mf">5.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="c1"># nan is not required here, could be anything</span>
<span class="mf">5.0</span>
</pre>
<p>Also the names float96/float128 are somewhat misleading. Under the hood it is not __float128 but whichever longdouble means in the local C++ flavor. On x86_64 Linux it is float80 (padded with zeros for memory alignment) which is certainly wider than float64, but it comes at the cost of the processing speed. Also you risk losing precision if you inadvertently convert to Python float type. For better portability it is recommended to use an alias np.longdouble instead of np.float96 / np.float128 because that's what will be used internally anyway.</p>
<p>More insights on floats can be found in the following sources:</p>
<p>&nbsp;•&nbsp;short and nicely illustrated <a class="reference external" href="https://observablehq.com/&#64;rreusser/half-precision-floating-point-visualized">‘Half-Precision Floating-Point, Visualized’</a> [2] <br/>&nbsp;&nbsp;&nbsp;— eg What’s the difference between normal and subnormal numbers?</p>
<p>&nbsp;•&nbsp;more lengthy but very to-the-point, a dedicated website <a class="reference external" href="https://floating-point-gui.de/">‘Floating point guide’</a> [3]  <br/>&nbsp;&nbsp;&nbsp;— eg Why 0.1+0.2!=0.3?</p>
<p>&nbsp;•&nbsp;long-read, a deep and thorough <a class="reference external" href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">What Every Computer Scientist Should Know About Floating-Point Arithmetic, Appendix D</a> [4]  <br/>&nbsp;&nbsp;&nbsp;— eg What’s the difference between catastrophic vs benign cancellation?</p>
</div>
<div class="section" id="bools">
<h2>3. Bools</h2>
<p>The boolean values are stored as single bytes for better performance. <cite>np.bool_</cite> is a separate type from Python’s bool because it doesn’t need reference counting and a link to the base class required for any pure Python type. So if you think that using 8 bits to store one bit of information is excessive look at this:</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">sys</span><span class="o">.</span><span class="n">getsizeof</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="mi">28</span>
</pre>
<p>np.bool is 28 times more memory efficient than Python’s bool ) – though in real-world scenarios the rate is lower: when you pack NumPy bools into an array, they will take 1 byte each, but if you pack Python bools into a list it will reference the same two values every time, costing effectively 8 bytes per element on x86_64:</p>
<img alt="NumPy Boolean Type" src="img/numpy-data-types/bools.png" />
<p>The underlines in <cite>bool_</cite>, <cite>int_</cite>, etc are there to avoid clashes with Python’s types. It’s a bad idea to use reserved keywords for other things, but in this case it has an additional advantage of allowing (a generally discouraged, but useful in rare cases) from NumPy import * without shadowing Python bools, ints, etc. As of today, np.bool still works but displays a deprecation warning.</p>
</div>
<div class="section" id="strings">
<h2>4. Strings</h2>
<p>Initializing a NumPy array with a list of Python strings packs them into a fixed-width native NumPy dtype called <cite>np.str_</cite>. Reserving a space necessary to fit the longest string for every element might look wasteful (especially in the fixed USC-4 encoding as opposed to ‘dynamic’ choice of the UTF width in Python str)</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">'abcde'</span><span class="p">,</span> <span class="s1">'x'</span><span class="p">,</span> <span class="s1">'y'</span><span class="p">,</span> <span class="s1">'x'</span><span class="p">])</span>        <span class="c1"># 4 bytes per any character</span>
<span class="n">array</span><span class="p">([</span><span class="s1">'abcde'</span><span class="p">,</span> <span class="s1">'x'</span><span class="p">,</span> <span class="s1">'y'</span><span class="p">,</span> <span class="s1">'x'</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'&lt;U5'</span><span class="p">)</span>  <span class="c1"># =&gt; 5*4 bytes per element</span>
</pre>
<p>The abbreviation ‘&lt;U4’ comes from the so called array protocol introduced in 2005. It means ‘little-endian USC-4-encoded string, 5 elements long’ (USC-4≈UTF-32, a fixed width, 4-bytes per character encoding). Every NumPy type has an abbreviation as unreadable as this one, luckily have they adopted human-readable names at least for the most used dtypes.</p>
<p>Another option is to keep references to Python strs in a NumPy array of objects:</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">'abcde'</span><span class="p">,</span> <span class="s1">'x'</span><span class="p">,</span> <span class="s1">'y'</span><span class="p">,</span> <span class="s1">'x'</span><span class="p">],</span> <span class="nb">object</span><span class="p">)</span>     <span class="c1"># 1 byte per ascii character</span>
<span class="n">array</span><span class="p">([</span><span class="s1">'abcde'</span><span class="p">,</span> <span class="s1">'x'</span><span class="p">,</span> <span class="s1">'y'</span><span class="p">,</span> <span class="s1">'x'</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>      <span class="c1"># =&gt; 49+len(el) per element</span>
</pre>
<p>The first array memory footprint amounts to 164 bytes, the second one takes 128 bytes for the array itself + 154 bytes for the three python strs:</p>
<img alt="NumPy Str_ Type" src="img/numpy-data-types/str.png" />
<p>Depending on the relative lengths of the strings and the number of the repeated string either one approach can be a significant win or the other.</p>
<p>If you're dealing with a raw sequence of bytes NumPy has a fixed-length version of a Python bytes type called <cite>np.bytes_</cite>:</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="sa">b</span><span class="s1">'abcde'</span><span class="p">,</span> <span class="sa">b</span><span class="s1">'x'</span><span class="p">,</span> <span class="sa">b</span><span class="s1">'y'</span><span class="p">,</span> <span class="sa">b</span><span class="s1">'x'</span><span class="p">])</span>        <span class="c1"># 1 byte per ascii character</span>
<span class="n">array</span><span class="p">([</span><span class="sa">b</span><span class="s1">'abcde'</span><span class="p">,</span> <span class="sa">b</span><span class="s1">'x'</span><span class="p">,</span> <span class="sa">b</span><span class="s1">'y'</span><span class="p">,</span> <span class="sa">b</span><span class="s1">'x'</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'|S5'</span><span class="p">)</span>  <span class="c1"># =&gt; 5 bytes per element</span>
</pre>
<p>Here <cite>|S5</cite> means ‘endianness-unappliable sequence of bytes 5 elements long’.</p>
<p>Once again, an alternative is to store the Python <cite>bytes</cite> in the NumPy array of objects.</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="sa">b</span><span class="s1">'abcde'</span><span class="p">,</span> <span class="sa">b</span><span class="s1">'x'</span><span class="p">,</span> <span class="sa">b</span><span class="s1">'y'</span><span class="p">,</span> <span class="sa">b</span><span class="s1">'x'</span><span class="p">],</span> <span class="nb">object</span><span class="p">)</span>   <span class="c1"># 1 byte per ascii character</span>
<span class="n">array</span><span class="p">([</span><span class="sa">b</span><span class="s1">'abcde'</span><span class="p">,</span> <span class="sa">b</span><span class="s1">'x'</span><span class="p">,</span> <span class="sa">b</span><span class="s1">'y'</span><span class="p">,</span> <span class="sa">b</span><span class="s1">'x'</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>    <span class="c1"># =&gt; 33+len(el) per element</span>
</pre>
<p>This time the first array takes 124 bytes, the second one is the same 128 bytes for the array itself + 106 bytes for the three python <cite>bytes</cite>:</p>
<img alt="NumPy Bytes_ Type" src="img/numpy-data-types/bytes.png" />
<p>We see that <cite>str_</cite> is smaller again, yet for more diverse lengths str can take the win.</p>
<p>As for the native <cite>np.str_</cite> and <cite>np.bytes_</cite> types, NumPy has a handful of common string operations mirroring str methods living in the np.char module that operate over the whole array:</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">upper</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="s1">'a'</span><span class="p">,</span><span class="s1">'b'</span><span class="p">],[</span><span class="s1">'c'</span><span class="p">,</span><span class="s1">'d'</span><span class="p">]]))</span>
<span class="n">array</span><span class="p">([[</span><span class="s1">'A'</span><span class="p">,</span> <span class="s1">'B'</span><span class="p">],</span>
       <span class="p">[</span><span class="s1">'C'</span><span class="p">,</span> <span class="s1">'D'</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'&lt;U1'</span><span class="p">)</span>
</pre>
<p>With object-mode strings the loops must happen on the Python level:</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="s1">'a'</span><span class="p">,</span><span class="s1">'b'</span><span class="p">],[</span><span class="s1">'c'</span><span class="p">,</span><span class="s1">'d'</span><span class="p">]],</span> <span class="nb">object</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">otypes</span><span class="o">=</span><span class="p">[</span><span class="nb">object</span><span class="p">])(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="s1">'A'</span><span class="p">,</span> <span class="s1">'B'</span><span class="p">],</span>
       <span class="p">[</span><span class="s1">'C'</span><span class="p">,</span> <span class="s1">'D'</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
</pre>
<p>According to my benchmarks, basic operations work somewhat faster with str than with <cite>np.str_</cite>.</p>
</div>
<div class="section" id="datetimes">
<h2>5. Datetimes</h2>
<p>NumPy introduces an interesting native data type for datetimes, similar to a POSIX timestamp (aka Unix time, the number of seconds since the midnight of 1 Jan 1970) but capable of counting time with a configurable granularity - from years to attoseconds - represented invariably by a single int64 number.</p>
<div class="figure">
<img alt="Datetime64 granularities table" src="img/numpy-data-types/granularities.png" />
<p class="caption">Table from the official <a class="reference external" href="https://numpy.org/doc/stable/reference/arrays.datetime.html">docs</a></p>
</div>
<ul class="simple">
<li>Years granularity means 'just count the years' - no real improvement against storing years as an integer.</li>
<li>Days granularity is an equivalent of Python's datetime.date.</li>
<li>Microseconds - of Python's datetime.datetime.</li>
</ul>
<p>And everything below is unique to np.datetime64.</p>
<p>When creating an instance of np.datetime64, NumPy chooses the most coarse granularity that can still hold such data:</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">'today'</span><span class="p">)</span>         <span class="c1"># days granularity (in local time UTC+7)</span>
<span class="n">numpy</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">'2021-12-25'</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">'now'</span><span class="p">)</span>           <span class="c1"># seconds granularity (in UTC)</span>
<span class="n">numpy</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">'2021-12-24 18:14:00'</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">utcnow</span><span class="p">())</span>     <span class="c1"># microsecond granularity</span>
<span class="n">numpy</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">'2021-12-24 18:14:23.404438'</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">'2021-12-24 18:14:23.404438123'</span><span class="p">)</span>   <span class="c1"># nanosecond granularity</span>
<span class="n">numpy</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">'2021-12-24 18:14:23.404438123'</span><span class="p">)</span>
</pre>
<p>Note that the string initializer is not so lenient as in pd.to_datetime: it must be in this exact format or minimal variations thereof (see 'general principles' of ISO 8601 wikipedia page).
When creating an array you decide if you are ok with the granularity that NumPy has chosen for you or you insist on, say, nanoseconds or what not and it'll give you 2⁶³ equidistant moments measured in the corresponding units of time to either side of 1 Jan 1970.</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">utcnow</span><span class="p">(),</span> <span class="s1">'datetime64[ns]'</span><span class="p">)</span>       <span class="c1"># us is too coarse for me!</span>
<span class="n">numpy</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">'2021-12-24 18:14:23.404438000'</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'datetime64[ns]'</span><span class="p">)</span>
</pre>
<p>It is possible to have a multiple of a base unit. For example, if you only need a precision of 0.1 sec, you don't necessarily need to store milliseconds:</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dt</span><span class="o">.</span><span class="n">utcnow</span><span class="p">()],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'datetime64[100ms]'</span><span class="p">);</span> <span class="n">a</span>
<span class="n">array</span><span class="p">([</span><span class="s1">'2022-12-24T18:15:08.300'</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'datetime64[100ms]'</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">array</span><span class="p">([</span><span class="s1">'2022-12-24T18:15:08.400'</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'datetime64[100ms]'</span><span class="p">)</span>
</pre>
<p>To get a machine-readable representation of the dtype without parsing the string:</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
<span class="n">dtype</span><span class="p">(</span><span class="s1">'&lt;M8[100ms]'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime_data</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="p">(</span><span class="s1">'ms'</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</pre>
<p>Just like in pure Python when you subtract one np.datetime64 from another you get a np.timedelta64 object (also represented as a single int64 with a configurable granularity). For example, to get the number of seconds until the New Year,</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">'2022-01-01'</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">now</span><span class="p">());</span> <span class="n">z</span>
<span class="n">numpy</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="mi">295345588878</span><span class="p">,</span><span class="s1">'us'</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">z</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>     <span class="c1"># constructing an ordinary timedelta, works with datetime64 too</span>
<span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">36353</span><span class="p">,</span> <span class="mi">424753</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">z</span><span class="o">.</span><span class="n">item</span><span class="p">()</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span>
<span class="mf">295553.424753</span>
</pre>
<p>Or if you don't care about the fractional part, simply</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">'2022-01-01'</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">now</span><span class="p">(),</span> <span class="s1">'s'</span><span class="p">)</span>
<span class="n">numpy</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="mi">295259</span><span class="p">,</span><span class="s1">'s'</span><span class="p">)</span>
</pre>
<p>Once constructed there's not much you can do about the datetime or timedelta objects. For the sake of speed the amount of available operations is kept to the bare minimum: only conversions and basic arithmetic. For example, there're no 'years' or 'days' helper methods.
To get a particular field from a datetime64/timedelta64 scalar you can convert it to a conventional datetime:</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">'2021-12-24 18:14:23'</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
<span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2021</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">000000</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">'2021-12-24 18:14:23'</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span><span class="o">.</span><span class="n">month</span>
<span class="mi">12</span>
</pre>
<p>For the arrays</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">'2021-12-15 09:00'</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">'2021-12-24 09:01'</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">'D'</span><span class="p">));</span> <span class="n">a</span>
<span class="n">array</span><span class="p">([</span><span class="s1">'2021-12-15T09:00'</span><span class="p">,</span> <span class="s1">'2021-12-18T09:00'</span><span class="p">,</span> <span class="s1">'2021-12-21T09:00'</span><span class="p">,</span>
       <span class="s1">'2021-12-24T09:00'</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'datetime64[m]'</span><span class="p">)</span>
</pre>
<p>you can either make conversions between np.datetime64 subtypes (faster)</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">'M8[M]'</span><span class="p">)</span> <span class="o">-</span> <span class="n">a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">'M8[Y]'</span><span class="p">))</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">14</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">23</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int64</span><span class="p">)</span>
<span class="ow">or</span> <span class="n">use</span> <span class="n">Pandas</span> <span class="p">(</span><span class="mi">2</span><span class="o">-</span><span class="mi">4</span> <span class="n">times</span> <span class="n">slower</span><span class="p">):</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DatetimeIndex</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="n">s</span>            <span class="c1"># or pd.to_datetime(a)</span>
<span class="n">DatetimeIndex</span><span class="p">([</span><span class="s1">'2021-12-15 09:00:00'</span><span class="p">,</span> <span class="s1">'2021-12-18 09:00:00'</span><span class="p">,</span>
               <span class="s1">'2021-12-21 09:00:00'</span><span class="p">,</span> <span class="s1">'2021-12-24 09:00:00'</span><span class="p">],</span>
              <span class="n">dtype</span><span class="o">=</span><span class="s1">'datetime64[ns]'</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">day</span>
<span class="n">Int64Index</span><span class="p">([</span><span class="mi">15</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">24</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'int64'</span><span class="p">)</span>
</pre>
<p>Here's a useful a function that can be used to decompose a datetime64 array to an array of 7 columns (years, months, days, hours, minues, seconds, microseconds):</p>
<pre class="code python literal-block">
<span class="k">def</span> <span class="nf">dt2cal</span><span class="p">(</span><span class="n">dt</span><span class="p">):</span>
    <span class="c1"># allocate output</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">7</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;u4&quot;</span><span class="p">)</span>
    <span class="c1"># decompose calendar floors</span>
    <span class="n">Y</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="n">dt</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;M8[</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="s2">&quot;YMDhms&quot;</span><span class="p">]</span>
    <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">+</span> <span class="mi">1970</span> <span class="c1"># Gregorian Year</span>
    <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">Y</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># month</span>
    <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">D</span> <span class="o">-</span> <span class="n">M</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># dat</span>
    <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dt</span> <span class="o">-</span> <span class="n">D</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;m8[h]&quot;</span><span class="p">)</span> <span class="c1"># hour</span>
    <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dt</span> <span class="o">-</span> <span class="n">h</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;m8[m]&quot;</span><span class="p">)</span> <span class="c1"># minute</span>
    <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dt</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;m8[s]&quot;</span><span class="p">)</span> <span class="c1"># second</span>
    <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dt</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;m8[us]&quot;</span><span class="p">)</span> <span class="c1"># microsecond</span>
    <span class="k">return</span> <span class="n">out</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">dt2cal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([[</span><span class="mi">2021</span><span class="p">,</span>   <span class="mi">12</span><span class="p">,</span>   <span class="mi">15</span><span class="p">,</span>    <span class="mi">9</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2021</span><span class="p">,</span>   <span class="mi">12</span><span class="p">,</span>   <span class="mi">18</span><span class="p">,</span>    <span class="mi">9</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2021</span><span class="p">,</span>   <span class="mi">12</span><span class="p">,</span>   <span class="mi">21</span><span class="p">,</span>    <span class="mi">9</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">2021</span><span class="p">,</span>   <span class="mi">12</span><span class="p">,</span>   <span class="mi">24</span><span class="p">,</span>    <span class="mi">9</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint32</span><span class="p">)</span>
</pre>
<p>A couple of gotchas with datetimes:</p>
<ol class="arabic simple">
<li>Even though leap years are supported,</li>
</ol>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">'2020-03-01'</span><span class="p">,</span> <span class="s1">'2022-03-01'</span><span class="p">,</span> <span class="s1">'2024-03-01'</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">)</span> <span class="o">-</span> \
    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">'2020-02-01'</span><span class="p">,</span> <span class="s1">'2022-02-01'</span><span class="p">,</span> <span class="s1">'2024-02-01'</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="mi">29</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">29</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'timedelta64[D]'</span><span class="p">)</span>
</pre>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Leap_second">Leap seconds</a> (essential part of both UTC and ordinary wall time) are not:</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">'2016-12-31T23:59:60'</span><span class="p">)</span>
<span class="ne">ValueError</span><span class="p">:</span> <span class="n">Seconds</span> <span class="n">out</span> <span class="n">of</span> <span class="nb">range</span> <span class="ow">in</span> <span class="n">datetime</span> <span class="n">string</span> <span class="s2">&quot;2016-12-31 12:59:60&quot;</span>
</pre>
<p>To be fair, neither datetime.datetime nor pytz count them, either (although in general <a class="reference external" href="https://stackoverflow.com/questions/19332902/extract-historic-leap-seconds-from-tzdata">it is possible</a> to extract info about leap seconds from pytz). time module supports them only formally (accepts 60th second, but incorrect intervals).</p>
<p>It looks as if only <a class="reference external" href="https://www.astropy.org/">astropy</a> processes them correctly so far,</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">astropy.time</span> <span class="kn">import</span> <span class="n">Time</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">(</span><span class="n">Time</span><span class="p">(</span><span class="s1">'2017-01-01'</span><span class="p">)</span> <span class="o">-</span> <span class="n">Time</span><span class="p">(</span><span class="s1">'2016-12-31 23:59'</span><span class="p">))</span><span class="o">.</span><span class="n">sec</span>
<span class="mf">61.00000000001593</span>
</pre>
<p>others adhere to <a class="reference external" href="https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar">proleptic Gregorian calendar</a> with its exactly 86400 SI seconds a day that has already gained about half a minute difference with the walltime since 1970 due to irregularities of the Earth rotation.
The practical implications of using this calendar are:
– mistake when calculating intervals that include one or more leap seconds
– exception when trying to construct a datetime64 from a timestamp taken during a leap second</p>
<ol class="arabic simple" start="2">
<li>As both np.datetime64 and np.timedelta64 have the same width, care must be taken with large timedeltas:</li>
</ol>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">'2262-01-01'</span><span class="p">,</span> <span class="s1">'ns'</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">'1678-01-01'</span><span class="p">,</span> <span class="s1">'ns'</span><span class="p">)</span>
<span class="n">numpy</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="o">-</span><span class="mi">17537673709551616</span><span class="p">,</span><span class="s1">'ns'</span><span class="p">)</span>
</pre>
<p>Finally, note that all the times in np.datetime64 are 'naive': they are not 'aware' of daylight saving (=&gt;it is recommended to store all datetimes in UTC) and are not capable of being converted from one timezone to another (=&gt;use pytz for timezone conversions):</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">'2022-01-01 12:00'</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">'2022-01-03 12:00'</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'D'</span><span class="p">))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime_as_string</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="s1">'2022-01-01T12:00'</span><span class="p">,</span> <span class="s1">'2022-01-02T12:00'</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'&lt;U35'</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime_as_string</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">timezone</span><span class="o">=</span><span class="s1">'local'</span><span class="p">)</span>
<span class="n">array</span><span class="p">([</span><span class="s1">'2022-01-01T19:00+0700'</span><span class="p">,</span> <span class="s1">'2022-01-02T19:00+0700'</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'&lt;U39'</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime_as_string</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">timezone</span><span class="o">=</span><span class="n">pytz</span><span class="o">.</span><span class="n">timezone</span><span class="p">(</span><span class="s1">'US/Eastern'</span><span class="p">))</span>
<span class="n">array</span><span class="p">([</span><span class="s1">'2022-01-01T07:00-0500'</span><span class="p">,</span> <span class="s1">'2022-01-02T07:00-0500'</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'&lt;U39'</span><span class="p">)</span>
</pre>
</div>
<div class="section" id="combinations-thereof">
<h2>6. Combinations thereof</h2>
<p>A structured array is an array with a custom dtype made from the types described above as the basic building blocks (akin to enum in C). Typical example is an RGB pixel color: a 4 bytes long type, in which the colors can be accessed by name:</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s1">'x'</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">),</span> <span class="p">(</span><span class="s1">'y'</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">),</span> <span class="p">(</span><span class="s1">'z'</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span> <span class="n">a</span>
<span class="n">array</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
      <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">'x'</span><span class="p">,</span> <span class="s1">'u1'</span><span class="p">),</span> <span class="p">(</span><span class="s1">'y'</span><span class="p">,</span> <span class="s1">'u1'</span><span class="p">),</span> <span class="p">(</span><span class="s1">'z'</span><span class="p">,</span> <span class="s1">'u1'</span><span class="p">)])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">'x'</span><span class="p">]</span>
<span class="mi">0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">'x'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="n">array</span><span class="p">([(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span>
      <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">'x'</span><span class="p">,</span> <span class="s1">'u1'</span><span class="p">),</span> <span class="p">(</span><span class="s1">'y'</span><span class="p">,</span> <span class="s1">'u1'</span><span class="p">),</span> <span class="p">(</span><span class="s1">'z'</span><span class="p">,</span> <span class="s1">'u1'</span><span class="p">)])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="s1">'z'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>
<span class="n">array</span><span class="p">([(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)],</span>
      <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">'x'</span><span class="p">,</span> <span class="s1">'u1'</span><span class="p">),</span> <span class="p">(</span><span class="s1">'y'</span><span class="p">,</span> <span class="s1">'u1'</span><span class="p">),</span> <span class="p">(</span><span class="s1">'z'</span><span class="p">,</span> <span class="s1">'u1'</span><span class="p">)])</span>
</pre>
<p>To be able to access the fields as attributes, a recarray can be used:</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span>
<span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)],</span>
          <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">'x'</span><span class="p">,</span> <span class="s1">'u1'</span><span class="p">),</span> <span class="p">(</span><span class="s1">'y'</span><span class="p">,</span> <span class="s1">'u1'</span><span class="p">),</span> <span class="p">(</span><span class="s1">'z'</span><span class="p">,</span> <span class="s1">'u1'</span><span class="p">)])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span>
<span class="mi">10</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">y</span><span class="o">=</span><span class="mi">7</span><span class="p">;</span> <span class="n">b</span>
<span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">)],</span>
          <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">'x'</span><span class="p">,</span> <span class="s1">'u1'</span><span class="p">),</span> <span class="p">(</span><span class="s1">'y'</span><span class="p">,</span> <span class="s1">'u1'</span><span class="p">),</span> <span class="p">(</span><span class="s1">'z'</span><span class="p">,</span> <span class="s1">'u1'</span><span class="p">)])</span>
</pre>
<p>Here it works like reinterpret_cast in C++, but sure enough, recarray can be created on its own, without being a view of something else.</p>
<p>Types for structured dtypes do not necessarily need to be homogenic and can even
include subarrays.</p>
<p>With structured arrays and recarrays can get the 'look and feel' of a basic Pandas DataFrame:&nbsp;<br/>&nbsp;&nbsp;&nbsp;– you can address columns by names,&nbsp;<br/>&nbsp;&nbsp;&nbsp;– do some arithmetic and statistic calculations with them,&nbsp;<br/>&nbsp;&nbsp;&nbsp;– some operations are faster in NumPy than in Pandas <br/>
but they lack:<br/>&nbsp;&nbsp;&nbsp;– grouping (except what is offered by itertools.groupby)&nbsp;<br/>&nbsp;&nbsp;&nbsp;– the mighty Pandas Index and MultiIndex (so no pivot tables) and <br/>&nbsp;&nbsp;&nbsp;– other niceties like convenient sorting, etc.</p>
</div>
<div class="section" id="type-checks">
<h2>7. Type Checks</h2>
<p>One way to check NumPy array type is to run isinstance against its element:</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>    <span class="c1"># might be np.int64 on a different OS</span>
<span class="kc">True</span>
</pre>
<p>All the NumPy types are interconnected in an inheritance tree displayed in the top of the article (blue=abstract classes, green=numeric types, yellow=others) so instead of specifying a whole list of types like isinstance(v, [np.int32, np.int64, etc]) you can write more compact typechecks like</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span>        <span class="c1"># true for all integers</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>         <span class="c1"># true for integers and floats</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">)</span>       <span class="c1"># true for floats except complex</span>
<span class="kc">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span> <span class="c1"># true for complex floats only</span>
<span class="kc">False</span>
</pre>
<p>The downside of this method is that it only works against a value of the array, not against the array itself. Which is not useful when the array is empty, for example. Checking the type of the array is more tricky.</p>
<p>For basic types the == operator does the job for a single type check:</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span>
<span class="kc">False</span>
</pre>
<p>and in operator for checking against a group of types:</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">half</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">single</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">longdouble</span><span class="p">)</span>
<span class="kc">False</span>
</pre>
<p>But for more sophisticated types like <cite>np.str_</cite> or <cite>np.datetime64</cite> they don’t.</p>
<p>The recommended way [5] of checking the dtype against the abstract types is</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">)</span>
<span class="kc">False</span>
</pre>
<p>It works with all native NumPy types, but the necessity of this method looks somewhat non-obvious: what’s wrong with good oldisinstance? Obviously the complexity of dtypes inheritance structure (they are constructed ‘on the fly’!) didn’t allow to do it according to principle of least astonishment.</p>
<p>If you have Pandas installed, its type checking tools work with NumPy dtypes, too:</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">is_float_dtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="kc">False</span>
</pre>
<p>Yet another method is to use (undocumented, but used in SciPy/NumPy code bases) np.typecodes dictionary. The tree it represents is way less branchy:</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">typecodes</span>
<span class="p">{</span><span class="s1">'Character'</span><span class="p">:</span> <span class="s1">'c'</span><span class="p">,</span>
<span class="s1">'Integer'</span><span class="p">:</span> <span class="s1">'bhilqp'</span><span class="p">,</span>
<span class="s1">'UnsignedInteger'</span><span class="p">:</span> <span class="s1">'BHILQP'</span><span class="p">,</span>
<span class="s1">'Float'</span><span class="p">:</span> <span class="s1">'efdg'</span><span class="p">,</span>
<span class="s1">'Complex'</span><span class="p">:</span> <span class="s1">'FDG'</span><span class="p">,</span>
<span class="s1">'AllInteger'</span><span class="p">:</span> <span class="s1">'bBhHiIlLqQpP'</span><span class="p">,</span>
<span class="s1">'AllFloat'</span><span class="p">:</span> <span class="s1">'efdgFDG'</span><span class="p">,</span>
<span class="s1">'Datetime'</span><span class="p">:</span> <span class="s1">'Mm'</span><span class="p">,</span>
<span class="s1">'All'</span><span class="p">:</span> <span class="s1">'?bhilqpBHILQPefdgFDGSUVOMm'</span><span class="p">}</span>
</pre>
<p>And the usage is like</p>
<pre class="code python literal-block">
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">typecodes</span><span class="p">[</span><span class="s1">'AllInteger'</span><span class="p">]</span>
<span class="kc">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">typecodes</span><span class="p">[</span><span class="s1">'Datetime'</span><span class="p">]</span>
<span class="kc">False</span>
</pre>
<p>This approach looks more hackish yet less magical than issubdtype.</p>
</div>
<div class="section" id="references">
<h2>References</h2>
<ol class="arabic simple">
<li>Ricky Reusser, <a class="reference external" href="https://observablehq.com/&#64;rreusser/half-precision-floating-point-visualized">Half-Precision Floating-Point, Visualized</a></li>
<li>Floating point guide <a class="reference external" href="https://floating-point-gui.de/">https://floating-point-gui.de/</a></li>
<li>David Goldberg, <a class="reference external" href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">What Every Computer Scientist Should Know About Floating-Point Arithmetic, Appendix D</a></li>
<li>NumPy issue <a class="reference external" href="https://github.com/numpy/numpy/issues/17325">#17325</a>, Add a canonical way to determine if dtype is integer, floating point or complex</li>
</ol>
</div>

            <aside>
            <nav>
            <ul class="articles_timeline">
 
                <li class="previous_article">« <a href="./pytest-vs-standard-django-tests.html" title="Previous: Pytest vs standard django tests">Pytest vs standard django tests</a></li>
            </ul>
            </nav>
            </aside>
<section style="clear:both">
<div class="accordion" id="accordion2">
    <div class="accordion-group">
        <div class="accordion-heading">
            <a class="accordion-toggle disqus-comment-count" data-toggle="collapse" data-parent="#accordion2" 
                href="./a-comprehensive-guide-to-numpy-data-types.html#disqus_thread">
                Comments
            </a>
        </div>
        <div id="disqus_thread" class="accordion-body collapse">
            <div class="accordion-inner">
                <div class="comments">
<div id="disqus_thread"></div>

<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>                </div>
            </div>
        </div>
    </div>
</div>
</section>
        </div>
        <section>
        <div class="span2" style="float:right;font-size:0.9em;">
 
            <h4>Published</h4>
            <time pubdate="pubdate" datetime="2022-01-03T12:28:52.794579+07:00">Jan 3, 2022</time>
 
            <h4>Last Updated</h4>
            <div class="last_updated">2022-01-03 12:28:52.794579+07:00</div>
            <h4>Category</h4>
            <a class="category-link" href="/categories.html#numpy-data-types-ref">numpy-data-types</a> 

			<div style="margin-top:10px">
				
				<!-- button -->
				<ins class="adsbygoogle"
					style="display:inline-block;width:125px;height:125px"
					data-ad-client="ca-pub-1413802869623200"
					data-ad-slot="8891641777"></ins>
				
			</div>
			
        </div>
        </section>
    </div>
    </article>
                </div>
                <div class="span1"></div>
            </div>
        </div>
    </div>
<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="http://oncrashreboot.com/pelican-elegant" title="Theme Elegant Home Page">Elegant</a> by <a href="http://oncrashreboot.com" title="Talha Mansoor Home Page">Talha Mansoor</a></li>
    </ul>
</div>
</footer>            
        
        


    </body>
</html>